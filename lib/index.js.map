{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";AAiBA,SAAS,8BAA8B,iBAAmC;AACxE,QAAM,gBAAgB,CAAC,SACrB,gBACG,OAAO,CAAC,SAAS,KAAK,SAAS,IAAI,EACnC,IAAI,CAAC,SAAS,KAAK,OAAO,EAC1B,KAAK,EAAE,EAAE;AAEd,QAAM,aAAa,gBAAgB,IAAI,CAAC,SAAS,KAAK,OAAO,EAAE,KAAK,EAAE,EACnE;AACH,QAAM,cAAc,cAAc,OAAO;AACzC,QAAM,cAAc,cAAc,OAAO;AACzC,QAAM,mBAAmB,cAAc,YAAY;AAEnD,UACG,cAAc,cAAc,MAAM,mBAAmB,OAAO;AAEjE;AAEA,SAAS,eAAe,GAAW,GAAW,kBAAkB,OAAO;AACrE,MAAI,iBAAiB;AACnB,WAAO,MAAM;AAAA,EACf;AACA,SAAO,EAAE,YAAY,MAAM,EAAE,YAAY;AAC3C;AAEO,SAAS,YACd,OACA,iBACA,EAAE,sBAAsB,eAAe,IAAuB,CAAC,GACvC;AAIxB,MAAI,MAAM,SAAS,gBAAgB,UAAU,CAAC,sBAAsB;AAClE,WAAO;AAAA,EACT;AAGA,MAAI,MAAM,SAAS,gBAAgB,UAAU,sBAAsB;AACjE,YAAQ,MAAM,OAAO,GAAG,gBAAgB,MAAM;AAAA,EAChD;AAGA,MAAI,UAAU,iBAAiB;AAC7B,WAAO;AAAA,MACL,OAAO,CAAC,EAAE,SAAS,OAAO,MAAM,QAAQ,CAAC;AAAA,MACzC,OAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,aAA+B,CAAC;AAEtC,QAAM,wBAAwB,MAAM,MAAM,EAAE;AAK5C,MAAI,uBAAiC,CAAC;AACtC,MAAI,uBAAiC,CAAC;AAGtC,WAAS,2BAA2B;AAClC,QAAI,qBAAqB,SAAS,GAAG;AACnC,iBAAW,KAAK;AAAA,QACd,SAAS,qBAAqB,KAAK,EAAE;AAAA,QACrC,MAAM;AAAA,MACR,CAAC;AACD,6BAAuB,CAAC;AAAA,IAC1B;AAAA,EACF;AAEA,WAAS,2BAA2B;AAClC,QAAI,qBAAqB,SAAS,GAAG;AACnC,iBAAW,KAAK;AAAA,QACd,SAAS,qBAAqB,KAAK,EAAE;AAAA,QACrC,MAAM;AAAA,MACR,CAAC;AACD,6BAAuB,CAAC;AAAA,IAC1B;AAAA,EACF;AAEA,WAAS,gCAAgC,iBAAiB;AACxD,UAAM,qBAAqB,sBAAsB,CAAC;AAGlD,QAAI,CAAC,oBAAoB;AACvB;AAAA,IACF;AAEA,UAAM,aAAa;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,QAAI,CAAC,YAAY;AAEf,2BAAqB,KAAK,4BAA4B;AAEtD,+BAAyB;AAEzB;AAAA,IACF;AAKA,0BAAsB,MAAM;AAG5B,yBAAqB,KAAK,4BAA4B;AAEtD,6BAAyB;AAGzB,QAAI,CAAC,sBAAsB,QAAQ;AACjC,+BAAyB;AAAA,IAC3B;AAAA,EACF;AAGA,MAAI,sBAAsB,SAAS,GAAG;AACpC,WAAO;AAAA,EACT;AAGA,QAAM,cAAc,WAAW,IAAI,CAAC,UAAU,MAAM,OAAO,EAAE,KAAK,EAAE;AAGpE,QAAM,iBAAiB,gBAAgB,QAAQ,aAAa,EAAE;AAG9D,MAAI,gBAAgB;AAClB,eAAW,KAAK,EAAE,SAAS,gBAAgB,MAAM,aAAa,CAAC;AAAA,EACjE;AACA,QAAM,QAAQ,8BAA8B,UAAU;AAEtD,SAAO;AAAA,IACL;AAAA,IACA,OAAO;AAAA,EACT;AACF","sourcesContent":["export type MatchRoleType = 'input' | 'fuzzy' | 'suggestion';\n\nexport interface FuzzyMatchPart {\n  content: string;\n  type: MatchRoleType;\n}\n\nexport interface FuzzyMatchData {\n  parts: FuzzyMatchPart[];\n  score: number;\n}\n\nexport interface FuzzyMatchOptions {\n  truncateTooLongInput?: boolean;\n  isCaseSesitive?: boolean;\n}\n\nfunction calculateFuzzyMatchPartsScore(fuzzyMatchParts: FuzzyMatchPart[]) {\n  const getRoleLength = (role: MatchRoleType) =>\n    fuzzyMatchParts\n      .filter((part) => part.type === role)\n      .map((part) => part.content)\n      .join('').length;\n\n  const fullLength = fuzzyMatchParts.map((part) => part.content).join('')\n    .length;\n  const fuzzyLength = getRoleLength('fuzzy');\n  const inputLength = getRoleLength('input');\n  const suggestionLength = getRoleLength('suggestion');\n\n  return (\n    (inputLength + fuzzyLength * 0.7 + suggestionLength * 0.9) / fullLength\n  );\n}\n\nfunction compareLetters(a: string, b: string, isCaseSensitive = false) {\n  if (isCaseSensitive) {\n    return a === b;\n  }\n  return a.toLowerCase() === b.toLowerCase();\n}\n\nexport function fuzzyString(\n  input: string,\n  stringToBeFound: string,\n  { truncateTooLongInput, isCaseSesitive }: FuzzyMatchOptions = {},\n): FuzzyMatchData | false {\n  // make some validation first\n\n  // if input is longer than string to find, and we dont truncate it - it's incorrect\n  if (input.length > stringToBeFound.length && !truncateTooLongInput) {\n    return false;\n  }\n\n  // if truncate is enabled - do it\n  if (input.length > stringToBeFound.length && truncateTooLongInput) {\n    input = input.substr(0, stringToBeFound.length);\n  }\n\n  // if input is the same as string to be found - we dont need to look for fuzzy match - return it as match\n  if (input === stringToBeFound) {\n    return {\n      parts: [{ content: input, type: 'input' }],\n      score: 1,\n    };\n  }\n\n  const matchParts: FuzzyMatchPart[] = [];\n\n  const remainingInputLetters = input.split('');\n\n  // let's create letters buffers\n  // it's because we'll perform matching letter by letter, but if we have few letters matching or not matching in the row\n  // we want to add them together as part of match\n  let ommitedLettersBuffer: string[] = [];\n  let matchedLettersBuffer: string[] = [];\n\n  // helper functions to clear the buffers and add them to match\n  function addOmmitedLettersAsFuzzy() {\n    if (ommitedLettersBuffer.length > 0) {\n      matchParts.push({\n        content: ommitedLettersBuffer.join(''),\n        type: 'fuzzy',\n      });\n      ommitedLettersBuffer = [];\n    }\n  }\n\n  function addMatchedLettersAsInput() {\n    if (matchedLettersBuffer.length > 0) {\n      matchParts.push({\n        content: matchedLettersBuffer.join(''),\n        type: 'input',\n      });\n      matchedLettersBuffer = [];\n    }\n  }\n\n  for (let anotherStringToBeFoundLetter of stringToBeFound) {\n    const inputLetterToMatch = remainingInputLetters[0];\n\n    // no more input - finish fuzzy matching\n    if (!inputLetterToMatch) {\n      break;\n    }\n\n    const isMatching = compareLetters(\n      anotherStringToBeFoundLetter,\n      inputLetterToMatch,\n      isCaseSesitive,\n    );\n\n    // if input letter doesnt match - we'll go to the next letter to try again\n    if (!isMatching) {\n      // add this letter to buffer of ommited letters\n      ommitedLettersBuffer.push(anotherStringToBeFoundLetter);\n      // in case we had something in matched letters buffer - clear it as matching letters run ended\n      addMatchedLettersAsInput();\n      // go to the next input letter\n      continue;\n    }\n\n    // we have input letter matching!\n\n    // remove it from remaining input letters\n    remainingInputLetters.shift();\n\n    // add it to matched letters buffer\n    matchedLettersBuffer.push(anotherStringToBeFoundLetter);\n    // in case we had something in ommited letters buffer - add it to the match now\n    addOmmitedLettersAsFuzzy();\n\n    // if there is no more letters in input - add this matched letter to match too\n    if (!remainingInputLetters.length) {\n      addMatchedLettersAsInput();\n    }\n  }\n\n  // if we still have letters left in input - means not all input was included in string to find - input was incorrect\n  if (remainingInputLetters.length > 0) {\n    return false;\n  }\n\n  // lets get entire matched part (from start to last letter of input)\n  const matchedPart = matchParts.map((match) => match.content).join('');\n\n  // get remaining part of string to be found\n  const suggestionPart = stringToBeFound.replace(matchedPart, '');\n\n  // if we have remaining part - add it as suggestion\n  if (suggestionPart) {\n    matchParts.push({ content: suggestionPart, type: 'suggestion' });\n  }\n  const score = calculateFuzzyMatchPartsScore(matchParts);\n\n  return {\n    score,\n    parts: matchParts,\n  };\n}\n"]}